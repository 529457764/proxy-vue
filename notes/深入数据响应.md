# 使用新特性实现一个简单的MVVM(2)--深入数据响应

## 概要
本篇将对之前的数据响应系统进行进一步优化，主要包括以下几点：

1. Proxy与DefineProperty
2. 深度监听
3. 依赖收集
4. 异步更新队列

## Proxy与DefineProperty
我们知道，Vue使用Object.defineProperty来实现数据的访问监听，为了更加深入的了解ES6新特性，在这里，我们使用Proxy来替代该方案。那么这两个方法会带来什么样的区别呢？

### 1. Proxy拥有更多的拦截方法
Proxy用于修改某些操作的默认行为，拦截目标对象的访问，对访问进行过滤和改写。我们看下他不仅可以设置get、set等操作，还可针对has,deleteProperty等各种操作进行拦截。而DefineProperty仅仅对get、set进行操作。

因此，Proxy给我们提供了更多的可能。

### 2. 作用在对象 vs 作用在属性
Object.defineProperty用于在一个对象上定义一个新属性，或者修改一个对象的现有属性。也就是说，我们是在对象的各属性上进行监听。因此，我们只能对对象的现有属性进行监听，类似这样：

```
function defineReactive (data, key) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      return val
    },
    set: function (newVal) {
      console.log('set=>>', key, newVal)
    }
  })
}

let obj = { a: 1, b: 2 }

Object.keys(obj).forEach(key => {
  defineReactive(obj, key)
})

obj.a = 2 // set=>> a 2
// c属性的变化并不会被监听到
obj.c = 3 
```

针对上述的问题，Vue采用，Vue.set方法对对象定义新的属性并添加监听，来避免这个问题。而Proxy，则用于监听整个对象，当我们为对象添加新属性的时候，依旧可以被监听到：

```
function defineReactive (data) {
  return new Proxy(data, {
    set (target, prop, value) {
      console.log('set=>>', prop, value)
      return Reflect.set(target, prop, value)
    }
  })
}

// 我们不需为每个属性进行监听，仅监听这个对象即可
let obj = defineReactive({ a: 1, b: 2 })

obj.a = 2 // set=>> a 2
// c属性的变化依旧被监听到
obj.c = 3 // set=>> c 3
```

可以看到，针对对象未定义的属性，我们依旧可以进行监听，很大程度上避免了不必要的麻烦。

### 3. 针对数组的监听
我们知道，针对数据变动的监听是通过setter来进行的。在操作数组的时候，我们经常会使用push、pop、shift等函数来进行操作，但是这种方式去修改数组，并不会触发setter。我们来试一下：

```
let arr = [ 1, 2, 3]
Object.keys(arr).forEach(key => {
  defineReactive(arr, key)
})

arr.push(4)  // 没有效果
arr.pop() // 同样没有效果
```
因此，我们往往需要使用变异方法来解决这个问题，创建一个新的Array，在数组方法被调用时，触发监听：

```
function observe (arr) {
  const methods = [‘push’, ‘pop’, ‘shift’…]
  let newArray = Object.create(Array.prototype)

  methods.forEach(mehod => {
    newArray[method] =  function (…args) {
      Array.prototype[method].apply(this, args)
      // 触发监听
      console.log(‘数组发生了改变！’)
    }
  })
  arr. setPrototypeOf(arr, newArray)
}
```
#### 限制
针对这种变异方法，还会导致两个问题，以下引自官方文档：
> 由于 JavaScript 的限制， Vue 不能检测以下变动的数组：
> 1. 当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue
> 2. 当你修改数组的长度时，例如： vm.items.length = newLength
> 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果， 同时也将触发状态更新：
> ```
> // Vue.set
> Vue.set(example1.items, indexOfItem, newValue)
> // Array.prototype.splice
> example1.items.splice(indexOfItem, 1, newValue)
> ```
> 为了解决第二类问题，你可以使用 splice：
> ```
> example1.items.splice(newLength)
> ```

我们来试试Proxy,可以发现，我们可以监听到数组的变动。同时，针对数组的变动，可能同时会修改其value和length。并且规避了上述的各种问题和限制，非常方便。
```
let arr = defineReactive([ 1, 2, 3 ])

arr.push(4)  // set=>> 3 4   set=>>length 4
arr.pop() // set =>> length 3
arr.length = 2 // set =>> length 2
arr[0] = 3 // set =>> 0 3
```

### 4. Proxy返回新的对象
我们看下Proxy的使用语法：

```
let res = new Proxy({ a: 1 }, {
  get () { …}
})
```

可以看出，针对我们监听的对象，返回的是一个新的Proxy引用，我们在使用时需注意规避这一特点带来的种种问题，后续在深度监听的介绍中也会提到。

## 深度监听
